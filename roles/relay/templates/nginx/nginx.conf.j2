user  www-data;

# Specifies the value for maximum file descriptors that can be opened by this process.
worker_rlimit_nofile 65536;
# multiple worker
worker_processes  {{ nginx_worker_processes | default('2') }};

error_log  /var/log/nginx/error.log;
pid /var/run/nginx.pid;

events {
  worker_connections  2048;

  # required by per_worker
  accept_mutex off;
}

http {
  types_hash_max_size 2048;

  log_format ip '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent"';
  access_log /var/log/nginx/access.log ip;

  # mime-types
  include /etc/nginx/mime.types;

  types {
      application/vnd.apple.mpegurl m3u8;
      video/mp2t ts;
  }

  # gzip settings
  gzip on;
  gzip_disable "msie6";
  gzip_comp_level 6;
  gzip_min_length  1100;
  gzip_buffers 16 8k;
  gzip_proxied any;
  gzip_types text/plain
             text/css
             text/js
             application/x-javascript
             text/javascript
             application/json;

  # sendfile() copies data between one file descriptor and another.
  # Because this copying is done within the kernel, sendfile() is more
  # efficient than the combination of read(2) and write(2), which would
  # require transferring data to and from user space.
  sendfile on;

  # disable directory listing
  autoindex off;

{% if nginx_frontend_master is not defined or nginx_frontend_master != 'yes' %}
  # FRONTEND caching directories
  proxy_cache_path /srv/nginx/cache/streaming_website/static
                   keys_zone=streaming_website_static:32m
                   max_size=256m
                   loader_threshold=300 loader_files=200;

  proxy_cache_path /srv/nginx/cache/streaming_website/pages
                   keys_zone=streaming_website_pages:32m
                   max_size=256m
                   loader_threshold=300 loader_files=200;

  upstream streaming_website {
{% for server in nginx_frontend_masters %}
    server {{ server }};
{% endfor %}
{% if nginx_frontend_server_backup is defined%}
    server {{ nginx_frontend_server_backup }} backup;
{% endif %}

    keepalive 8;
  }
{% else %}
  # FASTCGI FRONTEND-MASTER directory
  fastcgi_cache_path /srv/nginx/cache/streaming_fcgi
                     levels=1:2 keys_zone=streaming_fcgi:32m inactive=60m;
{% endif %}

{% if nginx_hls_master is not defined or nginx_hls_master != 'yes' %}
  # HLS slave caching directories
  proxy_temp_path /srv/nginx/cache/tmp;

  proxy_cache_path /srv/nginx/cache/hls
                   keys_zone=hls:32m
                   max_size=102400m
                   loader_threshold=300 loader_files=1024;

  upstream hls {
{% for server in nginx_hls_masters %}
    server {{ server }};
{% endfor %}

    keepalive 8;
  }
{% endif %}

  # DEFAULT vHOST for HLS
  server {
{% if nginx_bind_ipv4 is defined and nginx_bind_ipv6 is defined%}
    listen [{{ nginx_bind_ipv6 }}]:80 default_server ipv6only=off;
    listen {{ nginx_bind_ipv4 }}:80 default_server;
    listen 127.0.0.1:80 default_server;
    listen [::]:80 default_server;
{% else %}
    listen [::]:80 default_server ipv6only=off;
{% endif %}

    server_name _;

    root /var/www;

    # per-worker listener
    # 1st worker will listen 8000
    # 2nd worker will listen 8001
    # â€¦
    listen 9000 per_worker;

    location ~* /(.+\.ht|.+\.sh|.+\.git|.+\.htaccess|.+\.php)$ {
        deny  all;
    }

{% if nginx_hls_master is defined and nginx_hls_master == 'yes' %}
    location ~* ^/hls {
      root /tmp/;
      autoindex on;
    }

    # relive
    location ~ ^/crossdomain.xml {
            alias /srv/releases/relive/crossdomain.xml;
            include /etc/nginx/mime.types;
    }

    location ~* ^/releases/relive/(.+\.ts)$ {
      alias /srv/releases/relive/$1;
    }

    location ~* ^/releases/relive/(.*) {
      alias /srv/releases/relive/$1;
      autoindex on;
    }
{% else %}
    # proxy cache m3u8 (live, relive) and index.json (relive)
    #
    # live:   /hls/s2_native_sd.m3u8
    # relive: /releases/relive/19/index.m3u8
    #         /releases/relive/index.json
    #
    location ~* ^/(?<hls_or_relive>hls|releases\/relive)/(?<file>.+\.m3u8|index\.json)$ {
        proxy_intercept_errors on;
        proxy_cache            hls;
        proxy_set_header       Host $host;
        proxy_set_header       X-Real-IP $remote_addr;
        proxy_pass             http://hls/$hls_or_relive/$file;
        proxy_cache_methods    GET HEAD;
        proxy_cache_valid      200 302 1s;
        proxy_cache_key        "$uri";
        proxy_cache_lock       on;
        # keepalive to upstream server
        proxy_http_version          1.1;
        proxy_set_header Connection "";

        # client caching
        add_header Cache-Control no-cache;
        add_header X-Cache     "$upstream_cache_status edge";
    }
    # proxy cache ts files (live, relive)
    #
    # live:   /hls/s2_native_sd-13026687480.ts
    # relive: /releases/relive/29/1016.ts
    #
    location ~* ^/(?<hls_or_relive>hls|releases\/relive)/(?<stream>.+)\.ts$ {
        proxy_intercept_errors on;
        proxy_cache            hls;
        proxy_set_header       Host $host;
        proxy_set_header       X-Real-IP $remote_addr;
        proxy_pass             http://hls/$hls_or_relive/$stream.ts;
        proxy_cache_methods    GET HEAD;
        proxy_cache_valid      200 302 20m;
        proxy_cache_key        "$uri";
        proxy_cache_lock       on;
        # keepalive to upstream server
        proxy_http_version          1.1;
        proxy_set_header Connection "";

        limit_rate 3m;

        # client caching
        add_header Cache-Control no-cache;
        add_header X-Cache     "$upstream_cache_status edge";
    }
    # proxy cache thumbs (relive), index.html (relive) and crossdomain.xml (relive)
    #
    # relive: /crossdomain.xml
    #         /releases/relive/29/thumb.jpg
    #         /releases/relive/index.html
    #
    location ~* ^/(crossdomain\.xml|.+thumb\.jpg|.+index\.html)$ {
        proxy_intercept_errors on;
        proxy_cache            hls;
        proxy_set_header       Host $host;
        proxy_set_header       X-Real-IP $remote_addr;
        proxy_pass             http://hls/$1;
        proxy_cache_methods    GET HEAD;
        proxy_cache_valid      200 302 5m;
        proxy_cache_key        "$uri";
        proxy_cache_lock       on;
        proxy_ignore_headers   Cache-Control;
        # keep alive
        proxy_http_version          1.1;
        proxy_set_header Connection "";

        limit_rate 3m;

        # client caching
        add_header Cache-Control no-cache;
        add_header X-Cache     "$upstream_cache_status edge";
    }
{% endif %}

    # stats
    location ~* ^/stats/rtmp {
      rtmp_stat all;
      access_log off;

{% for ip in nginx_ips_allow_stats %}
      allow {{ ip }};
{% endfor %}
      deny all;
    }
    location ~* ^/stats/nginx {
      stub_status on;
      access_log   off;

{% for ip in nginx_ips_allow_stats %}
      allow {{ ip }};
{% endfor %}
      deny all;
    }

{% if nginx_frontend_master is defined and nginx_frontend_master == 'yes' %}
    location /stats/php {
      access_log off;

      include /etc/nginx/fastcgi_params;
      fastcgi_pass unix:/run/php5-fpm-www.sock;
      fastcgi_keep_conn on;
      fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;

{% for ip in nginx_ips_allow_stats %}
      allow {{ ip }};
{% endfor %}
      deny all;
    }
{% endif %}

{% if ansible_fqdn == "live.ber.c3voc.de" %}
    # TODO: move to mng.ber.c3voc.de
    location /tests {
      include /etc/nginx/mime.types;
      alias /srv/nginx/htdocs_tests;
      autoindex on;
    }

    location /releases {
      alias /srv/releases;
      autoindex on;
    }

    location /releases/private {
      alias /srv/releases/private;
      auth_basic "Auf zum Atem!!1!";
      auth_basic_user_file /etc/nginx/releases_htpasswd;
      autoindex on;
    }
{% endif %}

    location / {
      deny all;
    }
  }

  # FRONTEND vHOST
  server {
{% if nginx_bind_ipv4 is defined and nginx_bind_ipv6 is defined%}
    listen [{{ nginx_bind_ipv6 }}]:80;
    listen {{ nginx_bind_ipv4 }}:80;
{% else %}
    listen [::]:80;
{% endif %}

    server_name {{ loadbalancer.frontend.match_urls.is_streaming_website | join(' ') }};

    root /srv/nginx/htdocs;
    index index.html index.htm;

    error_page 404 = @404;
    error_page 500 501 502 503 504 = @500;

    location @500 {
      try_files /50x.html =500;
    }

    location @404 {
      try_files /404.php  =404;
    }

    location = /50x.html {
      alias /srv/nginx/htdocs/50x.html;
    }

{% if nginx_frontend_master is defined and nginx_frontend_master == 'yes' %}
    # FRONTEND MASTER
    location ~* /(.+\.ht|.+\.sh|.+\.git|.+\.htaccess)$ {
        deny  all;
    }
    # serve static files directly add client site caching expire times
    location ~* assets.+.(jpg|jpeg|gif|png|ico|ttf|svg|woff|swf)$ {
      expires 24h;
      add_header Cache-Control "public";
    }

    location ~* thumbs.+.png$ {
      expires 10m;
      add_header Cache-Control "public";
    }

    location ~* assets.+.(js|css|css.map)$ {
      expires 1h;
    }

    location ~* (index|404)\.php$ {
      include /etc/nginx/fastcgi_params;

      recursive_error_pages on;
      fastcgi_pass unix:/run/php5-fpm-www.sock;
      fastcgi_index index.php;
      fastcgi_param  SCRIPT_FILENAME  /srv/nginx/htdocs$fastcgi_script_name;
      # do not cache
      if ($arg_route ~* "feedback\/read") {
        set $do_not_cache 1;
      }
      # caching some php runs
      fastcgi_no_cache $do_not_cache;
      fastcgi_cache_bypass $do_not_cache;
      fastcgi_cache_key "$uri$is_args$args";
      fastcgi_cache streaming_fcgi;
      fastcgi_cache_valid 200 5m;
      fastcgi_cache_methods GET HEAD;
      add_header X-Cache "$upstream_cache_status origin";
    }

    location / {
      rewrite /(.*) /index.php?route=$1 last;
    }
{% else %}
    # FRONTEND SLAVE
    location ~* /(.+\.ht|.+\.sh|.+\.git|.+\.htaccess|.+\.php)$ {
        deny  all;
    }
    # caching static files or acces backend servers
    location ~* ^(?<path>.+)(?<ext>\.(css|css.map|png|jpeg|jpg|js|json))$ {
      proxy_intercept_errors on;
      proxy_cache            streaming_website_static;
      proxy_set_header       Host $host;
      proxy_set_header       X-Real-IP $remote_addr;
      proxy_pass             http://streaming_website$path$ext;
      # caching requested    files and pages
      proxy_cache_methods    GET HEAD;
      proxy_cache_valid      200 302 10m;
      proxy_cache_key        "$uri";
      # keepalive to upstream server
      proxy_http_version          1.1;
      proxy_set_header Connection "";

      add_header X-Cache     "$upstream_cache_status edge";
    }

    # do not cache feedback/read
    location ~* feedback\/read {
      proxy_intercept_errors on;
      proxy_set_header       Host $host;
      proxy_set_header       X-Real-IP $remote_addr;
      proxy_pass             http://streaming_website$uri;
      # do not cache
      proxy_cache_bypass     1;
      proxy_no_cache         1;
      # keep alive
      proxy_http_version          1.1;
      proxy_set_header Connection "";
      add_header X-Cache     "not cached edge";
    }

    location ~* .* {
      proxy_cache            streaming_website_pages;
      proxy_set_header       Host $host;
      proxy_set_header       X-Real-IP $remote_addr;
      proxy_pass             http://streaming_website$1;
      # caching requested    files and pages
      proxy_cache_methods    GET HEAD;
      proxy_cache_valid      200 302 5m;
      proxy_cache_key        "$uri";
      # keepalive to upstream server
      proxy_http_version          1.1;
      proxy_set_header Connection "";

      add_header X-Cache     "$upstream_cache_status edge";
    }
{% endif %}
  }
}


{% if nginx_hls_master is defined and nginx_hls_master == 'yes' %}
# HLS-Master configuration

# important for multi worker processes!!1!
rtmp_auto_push on;

rtmp {
  log_format rtmp '"$remote_addr [$time_local] $command "$app" "$name" "$args" - $bytes_received $bytes_sent "$pageurl" "$flashver" "$swfurl" "$tcurl" ($session_readable_time)"';
  access_log /var/log/nginx/rtmp_access.log rtmp;

  server {
{% if nginx_bind_ipv4 is defined and nginx_bind_ipv6 is defined %}
    listen [{{ nginx_bind_ipv6 }}]:1935 ipv6only=off;
    listen {{ nginx_bind_ipv4 }}:1935 ipv6only=off;
{% else %}
    listen [::]:1935 ipv6only=off;
{% endif %}
    ping 30s;

    # Disable audio until first video frame is sent.
    wait_video on;
    # Send NetStream.Publish.Start and NetStream.Publish.Stop to subscribers.
    publish_notify on;

    # Synchronize audio and video streams. If subscriber bandwidth is not
    # enough to receive data at ublisher rate some frames are dropped by
    # server. This leads to synchronization problem. When timestamp
    # difference exceeds the value specified as sync argument an absolute
    # frame is sent fixing that. Default is 300ms.
    sync 10ms;

    application stream {
      # enable live streaming
      live on;
      meta copy;

      hls on;
      hls_path /tmp/hls;
      hls_fragment 5s;
      hls_fragment_naming timestamp;
      hls_fragment_slicing aligned;
      hls_playlist_length 20m;
      hls_base_url /hls/;

{% if event.formats.hd is defined and event.formats.hd == 'yes' %}
      hls_variant _hd BANDWIDTH=2000000;
{% endif %}
{% if event.formats.sd is defined and event.formats.sd == 'yes' %}
      hls_variant _sd BANDWIDTH=1000000;
{% endif %}
{% if event.formats.slides is defined and event.formats.slides == 'yes' %}
      hls_variant _slides BANDWIDTH=100000;
{% endif %}

{% for stream, ip in nginx_streaming_locations.iteritems() %}
      pull rtmp://{{ ip }}:1935/stream/{{ stream }} name={{ stream }} static live=1;
{% endfor %}

{% for ip in nginx_ips_allow_to_push %}
      allow publish {{ ip }};
{% endfor %}
      deny publish all;

      allow play all;
    }
  }
}
{% endif %}
